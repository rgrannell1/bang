

"use strict"




const is         = require('is')
const request    = require('request')
const httpStatus = require('bang/commons/http-status')

const utils      = require('bang/commons/utils.js')
const rd         = require('bang/redirect.js')
const logger     = utils.logger





/*
	validateSuggestions :: any -> object

	check than a value can be used as search suggestions.

*/

var validateSuggestions = arr => {

	is.always.array(arr)

	if (arr.length < 2) {
		throw Error("suggestions must have at least two elements.")
	}

	is.always.string(arr[0])
	is.always.array(arr[1])

	arr[1].forEach(is.always.string)

	return arr

}





/*
	prepareSuggestions :: string x string x string -> string

	given the raw query passed from the browser, the
	search terms passed to the suggestion engine, and the corresponding
	opensearch-compliant terms generated by that engine.

	formats the suggestions with the original, raw search query,
	which the browser can consume.

	raw input:       !w cat
	search terms:    cat
	raw suggestions: [cat, [cattle, cats]]

	output:          [!w cat, [!w cattle, !w cats]]

*/

const prepareSuggestions = (rawQuery, pattern, body) => {

	try {

		const suggestions = validateSuggestions(JSON.parse(body))

		return [
			rawQuery,
			suggestions[1].map(elem => `${pattern} ${elem}`)
		]

	} catch (err) {

		logger.fatal({

			message: err.message,
			stack:   err.stack.toString( )

		}, 'failed to parse JSON suggestions')

		process.exit(1)

	}

}





/*
	giveSuggestions :: object -> {suggest: string, terms: string}

	return search results to the browser.

	TODO should call routine to get search results, serve to browser.
*/

const giveSuggestions = (browserResponse, redirected) => {

	giveSuggestions.precond(browserResponse, redirected)

	if (redirected.searchTerms.length === 0) {
		return
	}

	request(redirected.suggestionURL, (err, res, body) => {

		if (err) {

			logger.error({

				message: err.message,
				stack:   err.stack.toString( )

			}, 'request for suggestions failed.')

		} else if (!res) {

			logger.error('request for suggestions recieved no response.')

		} else if (res.statusCode !== httpStatus.ok) {

			logger.error({

				status: res.statusCode

			}, 'non-okay status returned.')

		} else {
			// OpenSearch compliant format [term, [sug1, sug2, ...]]

			browserResponse
			.status(httpStatus.ok)
			.set('Content-Type', 'application/json; charset=utf-8')
			.send(prepareSuggestions(redirected.rawQuery, redirected.bangPattern, body))
			.end( )

		}

	})

}

giveSuggestions.precond = (browserResponse, redirected) => {

	if (is.undefined(redirected)) {

		logger.fatal("redirected was undefined")
		process.exit(1)

	}

}




var suggest = (config, req, res) => {
	giveSuggestions(res, rd.redirect(req.query.q || ""))
}





module.exports = suggest
