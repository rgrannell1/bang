#!/usr/bin/env node




/*
	Bang! js

	A node server for redirecting queries to other search engines.

	This takes a bang operator (for example "!w") and a query
	(for example "glycerol"), and redirects the query to the website
	designated by the bang operator.

*/

const fs         = require('fs')
const is         = require('is')
const express    = require('express')
const request    = require('request')
const mustache   = require('mustache')
const httpStatus = require('./http-status')

const utils      = require('./utils.js')
const engines    = require('./engines.js')
const rd         = require('./redirect.js')

const format     = require('util').format

const logger     = utils.logger





/*
	serveHelp :: object -> undefined

	serve the help page back to the user.
*/

const serveHelp = function (res) {

	const view = {
		engines: engines.engines.map(engine => {

			return {
				patterns: engine.patterns,
				baseURL:  engine.baseURL
			}

		})
	}

	fs.readFile(utils.relative('help-template.html'), (err, template) => {

		res
		.set('Content-Type', 'text/html')
		.status(httpStatus.ok)
		.send(mustache.render(template.toString( ), view))
		.end( )

	})

}





/*
	redirectBrowser :: object -> object -> undefined

	redirect the browser to another search engine. The major
	action this application performs.

*/

const redirectBrowser = (res, redirected) => {

	if (is.undefined(redirected)) {
		logger.error("redirectBrowser: redirected was undefined")
	}

	const onlyEngine = redirected.searchTerms.replace(/\s/g).length === 0

	res
	.status(httpStatus.found)
	.set('Location', onlyEngine? redirected.baseURL : redirected.queryURL)
	.end( )

}




/*
	validateSuggestions :: any -> object

	check than a value can be used as search suggestions.

*/

validateSuggestions = arr => {

	if (!is.array(arr)) {
		throw TypeError("returned suggestions must be parsed to an array.")
	}

	if (arr.length < 2) {
		throw Error("suggestions must have at least two elements.")
	}

	if ( !is.string(arr[0]) ) {
		throw TypeError("the first elemement of suggestions must be a string.")
	}

	if ( !is.array(arr[1]) ) {
		throw TypeError("the second element of suggestions must be an array.")
	}

	arr[1].forEach((elem, ith) => {

		if (!is.string(elem)) {
			throw TypeError(`the ${ith} element of suggestions must be a string.`)
		}

	})

	return arr

}





/*
	prepareSuggestions :: string x string x string -> string

	given the raw query passed from the browser, the
	search terms passed to the suggestion engine, and the corresponding
	opensearch-compliant terms generated by that engine.

	formats the suggestions with the original, raw search query,
	which the browser can consume.

	raw input:       !w cat
	search terms:    cat
	raw suggestions: [cat, [cattle, cats]]

	output:          [!w cat, [!w cattle, !w cats]]

*/

const prepareSuggestions = (rawQuery, pattern, body) => {

	try {
		const suggestions = validateSuggestions(JSON.parse(body))
	} catch (err) {

		logger.error('failed to parse JSON suggestions: %s', err.message)
		return

	}

	return [
		rawQuery,
		suggestions[1].map(elem => `${pattern} ${elem}`)
	]

}





/*
	giveSuggestions :: object -> {suggest: string, terms: string}

	return search results to the browser.

	TODO should call routine to get search results, serve to browser.
*/

const giveSuggestions = (browserResponse, redirected) => {

	if (is.undefined(redirected)) {
		logger.error("giveSuggestions: redirected was undefined")
	}

	if (redirected.searchTerms.length === 0) {
		return // nothing to suggest.
	}

	request(redirected.suggestionURL, (err, res, body) => {

		if (err) {

			logger.error('request failed: %s', err.message)

		} else if (!res) {

			logger.error('request recieved no response: %s', err.message)

		} else if (res.statusCode !== httpStatus.ok) {

			logger.error(
				format("giveSuggestions: non-200 status returned by %s (%d)", redirected.suggestionURL, res.statusCode))

		} else {
			// OpenSearch compliant format [term, [sug1, sug2, ...]]

			browserResponse
			.status(httpStatus.ok)
			.set('Content-Type', 'application/json; charset=utf-8')
			.send(prepareSuggestions(redirected.rawQuery, redirected.bangPattern, body))
			.end( )

		}

	})

}





/*
	shutdown :: number -> undefined

	log that the process is being terminated.
*/

const shutdown = function (uptime) {
	return function ( ) {
		logger.info('terminating Bang! server after %d minutes of uptime.', (uptime( ) / (60000)).toFixed(2))
	}
}










/*
	BangServer

	This constructor creates a new bang server instance. This server
	takes queries of the form

	domain/search/?q={searchTerms}
	domain/suggest/?q={searchTerms}

	where searchTerms is some arbitrary search term. Bang's main use is
	to parse queries with special bang-syntax flags - like !twitter cats - and
	to direct the client to that search engine with a query primed for use on
	that site.


*/

const BangServer = function (services, config) {

	config        = config      || { }
	services      = services    || [ ]
	config.port   = config.port || process.env.port

	var app       = express( )
	const uptime  = utils.timer( )

	const version = require('../package.json').version




	app.get('/suggest', function (req, res) {
		/*
			find search suggestions.
		*/

		giveSuggestions(res, rd.redirect(req.query.q || ""))

	})

	app.get('/search', function (req, res) {
		/*
			redirect the url.
		*/

		const redirected    = rd.redirect(req.query.q || "")
		const requestedHelp = redirected.baseURL === utils.relative('help.html')

		requestedHelp
			? serveHelp(res)
			: redirectBrowser(res, redirected)

	})

	app.use(function (err) {
		logger.error(err)
	})





	app
	.listen(config.port, "localhost", function ( ) {

		logger.info(
			format('Bang! %s listening at http://localhost:%d (pid %d).',
				version, config.port, process.pid))

	})
	.on('error', function (err) {

		if (err.errno === 'EADDRINUSE') {
			logger.error('port %s currently in use.', config.port)
		} else {
			logger.error(err)
		}

	})





	process.on('SIGTERM', process.exit)
	process.on('SIGINT',  process.exit)
	process.on('exit',    shutdown(uptime))

	return app
}





module.exports = BangServer
