#!/usr/bin/env node

"use strict"





/*
	Bang! js

	A node server for redirecting queries to other search engines.

	This takes a bang operator (for example "!w") and a query
	(for example "glycerol"), and redirects the query to the website
	designated by the bang operator.

*/

const fs         = require('fs')
const is         = require('is')
const express    = require('express')
const request    = require('request')
const mustache   = require('mustache')
const httpStatus = require('./http-status')
const constants  = require('./constants')

const utils      = require('./utils.js')
const engines    = require('./engines.js')
const rd         = require('./redirect.js')

const format     = require('util').format

const logger     = utils.logger





/*
	serveHelp :: object -> undefined

	serve the help page back to the user.
*/

const serveHelp = res => {

	const view = {
		engines: engines.engines.map(engine => {

			return {
				patterns: engine.patterns,
				baseURL:  engine.baseURL
			}

		})
	}

	fs.readFile(constants.paths.HELP_PATH, (err, template) => {

		if (err) {
			throw Error('failed to load help template')
		}

		res
		.set('Content-Type', 'text/html')
		.status(httpStatus.ok)
		.send(mustache.render(template.toString( ), view))
		.end( )

	})

}





/*
	redirectBrowser :: object -> object -> undefined

	redirect the browser to another search engine. The major
	action this application performs.

*/

const redirectBrowser = (res, redirected) => {

	redirectBrowser.precond(res, redirected)

	const onlyEngine = redirected.searchTerms.replace(/\s/g).length === 0

	res
	.status(httpStatus.found)
	.set('Location', onlyEngine ? redirected.baseURL : redirected.queryURL)
	.end( )

}

redirectBrowser.precond = (res, redirected) => {

	if (is.undefined(redirected)) {
		logger.error("redirectBrowser: redirected was undefined")
	}

}





/*
	validateSuggestions :: any -> object

	check than a value can be used as search suggestions.

*/

var validateSuggestions = arr => {

	is.always.array(arr)

	if (arr.length < 2) {
		throw Error("suggestions must have at least two elements.")
	}

	is.always.string(arr[0])
	is.always.array(arr[1])

	arr[1].forEach(is.always.string)

	return arr

}





/*
	prepareSuggestions :: string x string x string -> string

	given the raw query passed from the browser, the
	search terms passed to the suggestion engine, and the corresponding
	opensearch-compliant terms generated by that engine.

	formats the suggestions with the original, raw search query,
	which the browser can consume.

	raw input:       !w cat
	search terms:    cat
	raw suggestions: [cat, [cattle, cats]]

	output:          [!w cat, [!w cattle, !w cats]]

*/

const prepareSuggestions = (rawQuery, pattern, body) => {

	try {

		const suggestions = validateSuggestions(JSON.parse(body))

		return [
			rawQuery,
			suggestions[1].map(elem => `${pattern} ${elem}`)
		]

	} catch (err) {

		logger.error({message: err.message}, 'failed to parse JSON suggestions')
		return

	}

}





/*
	giveSuggestions :: object -> {suggest: string, terms: string}

	return search results to the browser.

	TODO should call routine to get search results, serve to browser.
*/

const giveSuggestions = (browserResponse, redirected) => {

	giveSuggestions.precond(browserResponse, redirected)

	if (redirected.searchTerms.length === 0) {
		return
	}

	request(redirected.suggestionURL, (err, res, body) => {

		if (err) {

			logger.error({message: err.message}, 'request failed')

		} else if (!res) {

			logger.error('request recieved no response')

		} else if (res.statusCode !== httpStatus.ok) {

			logger.error({
				url:    redirected.suggestionURL,
				status: res.statusCode
			}, 'non-okay status returned.')

		} else {
			// OpenSearch compliant format [term, [sug1, sug2, ...]]

			browserResponse
			.status(httpStatus.ok)
			.set('Content-Type', 'application/json; charset=utf-8')
			.send(prepareSuggestions(redirected.rawQuery, redirected.bangPattern, body))
			.end( )

		}

	})

}

giveSuggestions.precond = (browserResponse, redirected) => {

	if (is.undefined(redirected)) {
		logger.error("giveSuggestions: redirected was undefined")
	}

}





/*
	shutdown :: number -> undefined

	log that the process is being terminated.
*/

const shutdown = uptime => {

	logger.info({
		uptime: (uptime( ) / (60 * 1000)).toFixed(2)
	}, 'terminating Bang! server')

}










/*
	BangServer

	This constructor creates a new bang server instance. This server
	takes queries of the form

	domain/search/?q={searchTerms}
	domain/suggest/?q={searchTerms}

	where searchTerms is some arbitrary search term. Bang's main use is
	to parse queries with special bang-syntax flags - like !twitter cats - and
	to direct the client to that search engine with a query primed for use on
	that site.


*/

const BangServer = function (services, config) {

	config        = config      || { }
	services      = services    || [ ]
	config.port   = config.port || process.env.port

	var app       = express( )
	const uptime  = utils.timer( )





	app.get('/suggest', (req, res) => {
		/*
			find search suggestions.
		*/

		giveSuggestions(res, rd.redirect(req.query.q || ""))

	})

	app.get('/search', (req, res) => {
		/*
			redirect the url.
		*/

		const redirected    = rd.redirect(req.query.q || "")
		const requestedHelp = redirected.baseURL === utils.relative('help.html')

		requestedHelp
			? serveHelp(res)
			: redirectBrowser(res, redirected)

	})

	app.use(err => {
		logger.error(err)
	})





	app
	.listen(config.port, "localhost", ( ) => {

		logger.info({
			port:    config.port,
			pid:     process.pid,
			version: constants.version
		},
		'Bang! listening')

	})
	.on('error', err => {

		if (err.errno === 'EADDRINUSE') {
			logger.error({port: config.port}, 'port currently in use.')
		} else {
			logger.error(err)
		}

	})





	process.on('SIGTERM', process.exit)
	process.on('SIGINT',  process.exit)
	process.on('exit',    shutdown.bind({ }, uptime))

	return app
}





module.exports = BangServer
