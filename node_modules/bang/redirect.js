
"use strict"





var is             = require('is')
var URL            = require('url')

var constants      = require('bang/commons/constants')
var httpStatus     = require('bang/commons/http-status')
var enginePatterns = require('bang/data/engines.json')
var logger         = require('bang/logging/logger')
var Engine         = require('bang/model/engine')




var withWordBoundary = word => {

	withWordBoundary.precond(word)

	var WORD_BOUNDARY = constants.regex.WORD_BOUNDARY
	var escapedWord   = word.split('').map(char => `[${char}]`).join('')

	return new RegExp(WORD_BOUNDARY + escapedWord + WORD_BOUNDARY, 'i')

}

withWordBoundary.precond = word => {

	is.always.string(word)

	var metacharacters = [']', '\\', '^', '-']

	word.split('').forEach(char => {

		var isMetacharacter = metacharacters.indexOf(char) !== -1

		if (isMetacharacter) {
			throw Error(`${char} in ${word} is a metacharacter and cannot currently be escaped.`)
		}

	})

}





var queryMatchesEngine = (rawQuery, engine) => {

	queryMatchesEngine.precond(rawQuery, engine)

	return engine.patterns.some(pattern => {
		return withWordBoundary(pattern).test(rawQuery)
	})

}

queryMatchesEngine.precond = (rawQuery, engine) => {

	is.always.string(rawQuery)
	is.always.object(engine)

}





var findDefaultEngine = engines => {

	findDefaultEngine.precond(engines)

	for (var ith = 0; ith < engines.length; ++ith) {

		if (engines[ith].isDefault) {
			return engines[ith]
		}

	}

	throw Error('could not find default search engine.')
}

findDefaultEngine.precond = engines => {
	is.always.array(engines)
}





var findMatchingEngine = rawQuery => {

	findMatchingEngine.precond(rawQuery)

	var engines         = enginePatterns.map(Engine)
	var matchingEngines = engines.filter(queryMatchesEngine.bind({ }, rawQuery))

	return matchingEngines.length > 0
		? matchingEngines[0]
		: findDefaultEngine(engines)

}

findMatchingEngine.precond = rawQuery => {
	is.always.string(rawQuery)
}





var searchTermsToUrl = (searchTerms, engine) => {

	searchTermsToUrl.precond(searchTerms, engine)

	return searchTerms.length === 0
		? engine.baseUrl
		: URL.parse(engine.searchTemplate.replace(/{searchTerms}/g, searchTerms), true).href

}

searchTermsToUrl.precond = (searchTerms, engine) => {
	is.always.string(searchTerms)
	is.always.object(engine)
}





var extractSearchTerms = (rawQuery, engine) => {

	return engine.patterns.reduce((query, pattern) => {
		return query.replace(withWordBoundary(pattern), '')
	}, rawQuery)

}

extractSearchTerms.precond = (rawQuery, engine) => {
	is.always.string(searchTerms)
	is.always.object(engine)
}





var redirect = { }





redirect.toSearchEngine = (config, rawQuery, res) => {

	redirect.toSearchEngine.precond(config, rawQuery, res)

	var matchingEngine = findMatchingEngine(rawQuery)
	var searchTerms    = extractSearchTerms(rawQuery, matchingEngine)
	var redirectUrl    = searchTermsToUrl(searchTerms, matchingEngine)

	if (config.trace) {

		logger.info({

			rawQuery,
			searchTerms,
			redirectUrl

		}, 'request redirected.')

	}

	res
	.status(httpStatus.temporaryRedirect)
	.set('Location', redirectUrl)
	.end( )

}

redirect.toSearchEngine.precond = (config, rawQuery, res) => {

	is.always.object(config)
	is.always.string(rawQuery)

}






redirect.toHelpFile = (config, rawQuery, res) => {

	redirect.toHelpFile.precond(config, rawQuery, res)

	if (config.trace) {

		logger.info({

			rawQuery,
			redirectUrl: 'about'

		}, 'request redirected.')

	}
	res
	.status(httpStatus.temporaryRedirect)
	.set('Location', 'about')
	.end( )

}

redirect.toHelpFile.precond = (config, rawQuery, res) => {
	is.always.object(config)
	is.always.string(rawQuery)
}




module.exports = redirect
